import _ from "lodash";
import R from "ramda";
import { NAMES } from "./constants";
import { isValid } from "./utils";

// 함수 체인과 함수 파이프라인 비교
// 함수형 라이브러리: 람다 JS
// 커링, 부분 적용, 함수 바인딩 개념 탐국
// 함수 합성으로 모듈적인 프로그램 제작
// 함수 조합기로 프로그램의 흐름 개선

// 모듈성(modularity): 대규모 소프트웨어 프로젝트에서 매우 중요
// 프로그램을 작고 독립적인 부분으로 나눌 수 있는 정도
// 부속은 그대로 또는 더 쪼개서 통합할 수 있는 재사용 가능한 컴포넌트이다.
// 생산성을 높이고 코드 유지보수성 및 가독성을 향상시키는데 도움이 된다.

// 파이프라이닝
// 함수를 연결하는 (체이닝과는) 또 다른 기법
// 함수는 입력과 출력을 기준으로 서술하는 것이 유용하다.

// 하스켈 함수 표기법
// <function-name> :: <Inputs*> -> <Output>
// [함수명]  [형식을 알려주는 연산자] [0개 이상의 입력 형식] -> [단일 출력 형식]

// 함수형 프로그래밍에서 함수란 입력 형식과 출력 형식 간의 수학적인 매핑을 뜻한다.
// 예) isEmpty :: String -> Boolean
const isEmpty = s => !s || !s.trim();
// console.log(isEmpty(" "));
// console.log(isEmpty(" not empty! "));

// 함수를 형식 간의 매핑으로 바라보아야 한다.
// 메서드를 체이닝(단단한 결합, 제한된 표현성)
// 함수 파이프라인을 배열(느슨한 결합, 유연성)

// 4.2. 메서드를 체이닝
// 암시적으로 생성된 Lodashwrapper객체를 매개로 이들 함수를 서로 체이닝하면서
// 물밑에서 전혀 새로운 자료구조를 만든다.
const result = _.chain(NAMES)
  .filter(isValid)
  .map(s => s.replace(/_/, " "))
  .uniq()
  .map(_.startCase)
  .sort()
  .value();
// console.log(result);

// 구조적으로 향상되었고, 가독성도 엄청 좋지만,
// 자신을 소유한 객체에 부자연스럽게 매여 있고, 체인에서 실행 가능한 메서드 가짓수가 줄고 코드의 표현성도 제약을 받는다.
// 로대시JS가 제공한 연산만 쓸 수 있어 다른 라이브러리 함수를 쉽게 연결할 수 없다.
// (믹스인을 통한 확장이 가능하지만 만들어진 믹스인 객체를 책임지고 관리해야 한다.)
